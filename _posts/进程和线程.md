# 进程和线程

## 一、进程

### 1、进程的概念

- 进程是程序的一次执行过程
- 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位

> 这里所说的系统资源指处理机、存储器和其他设备服务于某个进程的“时间”。例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，即"时间片"分配的独立单位，这就决定了进程是一个动态的、过程性的概念。

### 2、进程的特征

1. 动态性：进程是程序的一次执行过程，因创建而产生，因调度而执行，因无资源而暂停，因撤消而消亡；而程序是静态实体
2. 并发性：多个进程实体同存于内存中，能在一段时间同时运行
3. 独立性：传统OS中，进程是能独立运行的基本单位
4. 异步性：进程之间相互制约，进程以各自独立的不可预知的速度向前推进；会导致执行结果的不可再现性

### 3、进程的状态与转换

> 进程有三种基本状态

1. 运行态：进程正在处理机上运行。单处理机中，每个时刻只有一个进程处于运行态
2. 就绪态：进程获得了除处理机外的一切资源，一旦得到处理机即可运行。
3. 阻塞态：又称等待态；进程因等待某一事件而暂停运行，即使处理机空闲也不能运行。（比如等待某一资源，IO操作完成）

- 状态转换如下图所示

![image-20220502145240841](C:\Users\WYF\AppData\Roaming\Typora\typora-user-images\image-20220502145240841.png)

> 需要注意的是，一个进程从运行态变成阻塞态是主动的行为，而从阻塞态变到就绪态是被动的行为，需要其他相关进程的协助

### 4、进程的组织

一个进程由以下三部分组成

#### 4.1 进程控制块

- 进程创建时，操作系统为他新建一个PCB（进程控制块），任意时刻都可以存取，并在进程结束时删除。**PCB是进程存在的唯一标志**

> 当操作系统要调度某进程运行时，要从该进程的PCB中查出其现行状态及优先级；调度到某进程时，要根据PCB中保存的处理机状态信息，设置进程恢复运行的现场，并根据PCB中程序和数据的内存始址，找到程序和数据；当进程暂停运行时，需将断点的处理机环境保存在PCB中

- PCB的内容主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息
  - 进程描述信息。进程id，每个进程都有唯一id；用户标识符，进程归属的用户，主要为共享和保护服务
  - 进程控制和管理信息。保存着当前状态、优先级、代码运行入口地址、程序外存地址、信号量使用等信息
  - 资源分配清单：列出所拥有的除CPU外的资源记录，包括代码段、数据段、堆栈段的指针及IO设备的信息
  - 处理机相关信息：也称处理机的上下文。主要指处理机中各寄存器的值

#### 4.2 程序段

- 程序段是能被进程调度程序调度到CPU执行的程序代码段。

> 程序可被多个进程共享，即多个进程可以运行同一个程序

#### 4.3 数据段

- 是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果

### 5、进程通信

进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式，主要有以下三类

#### 5.1 共享存储

- 通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现信息交换
- 进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现
- 若某进程要访问共享存储空间，则必须没有其他进程在该共享存储空间中进行写操作，否则访问行为就会被阻塞。

#### 5.2 消息传递

- 进程通过系统提供的发送消息和接收消息两个原语进行数据交换，这种方式隐藏了通信实现细节，使通信过程对用户透明
  - 直接通信方式：发送进程直接把消息发送给接受进程，并将它挂在接受进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息
  - 间接通信方式：发送进程把消息发送到某个中间实体（一般称为信箱），接受进程从中间实体取得消息

#### 5.3 管道通信

- “管道”指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件
- 从管道读数据是一次性操作，数据一旦被读取，就释放空间以便写更多数据。管道只能采用半双工通信，即某一时刻只能单向传输。
- 管道通信中，存储空间进化为了缓冲区，缓冲区只允许一边写入，另一边读出。写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写数据

## 二、线程

### 1、线程的概念

进程的不足：

- 进程只能在一个时间处理一个任务，不能同时处理多个任务
- 如果进程在执行时阻塞，整个进程都无法继续执行

需要提出一种满足以下特性的实体：

- 实体之间可以并发执行
- 实体之间共享相同的地址空间

现代操作系统将资源拥有者称为进程（process），将可执行单元称为线程（thread）

- 线程是一个基本的CPU执行单元，由线程ID，程序计数器，寄存器集合和堆栈组成。
- 线程是进程中的一个实体，是系统独立调度和分派的基本单位
- 同一进程的线程之间可共享资源。

### 2、线程与进程的比较

#### 2.1 调度

- 传统操作系统中，拥有资源和独立调度的基本单位都是进程，每次调度都要进行上下文切换，开销较大
- 引入线程的操作系统中，线程是独立调度的基本单位。同一进程中的线程切换开销较小

#### 2.2 拥有资源

- 进程是拥有资源的基本单位，线程不拥有系统资源（仅拥有必不可少、保证独立运行的资源）
- 线程可以访问其隶属进程的系统资源，这主要表现在**属于同一进程的所有线程都有相同的地址空间**

> 要知道， 若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义

![image-20220502153710221](C:\Users\WYF\AppData\Roaming\Typora\typora-user-images\image-20220502153710221.png)

#### 2.3 独立性

- 每个进程都有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问
- 某进程中的线程对其他进程不可见，同一进程中的不同线程是为了提高并发性及进行相互合作而创建的，他们共享进程的地址空间和资源

> 那么为什么说线程的提出有利于提高系统的并发性呢？

- 线程切换时，有可能发生进程切换，也有可能进程不切换，平均而言每次切换所需的开销变小了，因此能让更多的线程参与并发，而不会影响到响应时间等问题

### 3、线程的实现方式

#### 3.1 用户级线程（ULT）

- 用户级线程中，有关线程管理（创建、撤销和切换）的所有工作都由应用程序在用户空间完成，内核意识不到线程的存在
- 由于线程在进程内切换的规则远比进程调度和切换的规则简单，不需要用户态/内核态的切换，因此切换速度快
- 每个线程并不具有自身的线程上下文，因此就线程的同时执行而言，任意给定时刻**每个进程只能够有一个线程在运行**，而且只有一个处理器内核会被分配给该进程，不能发挥多处理机的优势
- 系统调用的阻塞问题：当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞

![image-20220502155859672](C:\Users\WYF\AppData\Roaming\Typora\typora-user-images\image-20220502155859672.png)

#### 3.2 内核级线程（KLT）

- 内核空间为每个内核级线程设置一个线程控制块，内核根据该控制块感知某线程的存在，并对其加以控制
- 能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行
- 若一个线程被阻塞，内核可调度该进程中的其他线程占用处理机，也可以运行其他进程中的线程
- 系统开销较大：同一进程中的线程切换，需要从用户态转到核心态进行。这是因为用户进程的线程在用户态进行，而线程调度和管理在内核实现

![image-20220502160811522](C:\Users\WYF\AppData\Roaming\Typora\typora-user-images\image-20220502160811522.png)

总结：

- **用户级线程执行系统调用指令时将导致其所属进程被中断，而内核级线程执行系统调用指令时，只导致该线程被中断。**
- **用户级线程的程序实体是运行在用户态下的程序，而内核级线程的程序实体则是可以运行在任何状态下的程序。**
- **在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行在有内核级线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。**

#### 3.3 组合方式

- 内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户及线程
- 一些内核级线程可对应多个用户级线程
- 同一进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞

![image-20220502161821752](C:\Users\WYF\AppData\Roaming\Typora\typora-user-images\image-20220502161821752.png)

### 4、多线程模型

#### 4.1 多对一模型

- 将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（即透明），仅当用户线程需要访问内核时，才将其映射到一个内核级线程上
- 优点：线程管理是在用户空间进行的，因而效率比较高。
- 缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上

#### 4.2 一对一模型

- 将每个用户级线程映射到一个内核级线程。
- 优点：当一个线程被阻塞后，允许调度另一个线程继续执行，所以并发能力较强。
- 缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。

#### 4.3 多对多模型

- 将 n 个用户级线程映射到m 个内核级线程上，要求m <= n。

- 在多对一模型和一对一模型中取了个折中， 克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进 

  程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。