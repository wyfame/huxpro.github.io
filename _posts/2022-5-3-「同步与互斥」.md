---
layout: "post"
title: "「BUAA-OS」同步与互斥"
subtitle: ""
author: "wyfame"
date: 2022-5-3

tags: ["操作系统","北航"]
lang: zh
catalog: true
header-image: ""
header-style: text
---

# 同步与互斥

## 一、同步互斥基本概念

### 1、临界资源

- 临界资源：一次仅允许一个进程使用的资源称为临界资源

- 临界区：每个进程中访问临界资源的代码

  临界资源的访问分为四个步骤

  - 进入区：在进入区检查是否可进入临界区，若能进入临界区，则设置正在访问临界区的标志，以阻止其他进程同时进入临界区
  - 临界区：进程中访问临界资源的代码
  - 退出区：将正在访问临界区的标志清除
  - 剩余区：代码的其余部分

### 2、同步

- 同步又称直接制约关系，指为完成某个任务建立的两个或多个进程，因在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系
- 直接制约关系来源于它们之间的相互合作

### 3、互斥

- 互斥又称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待。

### 4、临界区管理准则

1. **空闲让进**：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
2. **忙则等待**：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
3. **有限等待**：对请求访问的进程，应保证能在有限时间内进入临界区
4. **让权等待**：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待

## 二、实现临界区互斥的基本方法

### 1、软件实现方法

在进入区设置并检查一些标志来表明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志

#### 1.1 单标志法

- 设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号，即若turn=0，则允许$P_0$进入临界区。
- 该算法可确保每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（违背空闲让进）

```c
P0进程：															  P1进程：
while(turn != 0);													while(turn != 1);		//进入区
critical section;													critical section;		//临界区
turn = 1;															turn = 0;				//退出区
remainder section;													remainder section;    	//剩余区         
```

> 若$P_0$从临界区离开，此时临界区空闲，turn = 1，而$P_1$不进入临界区，$P_0$就一直无法进入临界区

#### 1.2 双标志法先检查

- 设置数据flag[i]，如第i个元素为false，则表示$P_i$未进入临界区，true则为进入临界区

```c
Pi进程：															  Pj进程：
while(flag[j]);														while(flag[i]);			//进入区
flag[i] = true;														flag[j] = true;			//进入区
critical section;													critical section;		//临界区
flag[i] = false;													flag[j] = true;			//退出区
remainder section;													remainder section;    	//剩余区
```

> 每个进程进入前都需要循环遍历其他进程的flag，若为true则继续等待；若此时1进程进入临界区，它在检查flag值和设置自己的flag为true两个操作之间会有一段时间，此段时间内flag[1]还未被设为true，2进程可能会同时进入临界区，违背（忙则等待）

#### 1.3 双标志法后检查

- 为解决上述算法的问题，此算法先将自己的标志置为true，再去检查其他的标志

```c
Pi进程：															  Pj进程：
flag[i] = true;														flag[j] = true;			//进入区
while(flag[j]);														while(flag[i]);			//进入区
critical section;													critical section;		//临界区
flag[i] = false;													flag[j] = true;			//退出区
remainder section;													remainder section;    	//剩余区
```

> 两个进程几乎同时想进入临界区，都将自己设为true，结果检查时就互相谦让，都无法进入，导致“饥饿”现象

#### 1.4 Peterson's Algorithm

- 又设置了turn，每个进程先设置自己的标志后再设置turn，这是再检测另一个进程状态标志和turn标志。

```c
Pi进程：														  Pj进程：
flag[i] = true;turn = j;										flag[j] = true;turn = i;		//进入区
while(flag[j] && turn == j);									while(flag[i] && turn == i);	//进入区
critical section;												critical section;				//临界区
flag[i] = false;												flag[j] = true;					//退出区
remainder section;												remainder section;    			//剩余区
```

- 对于i进程，一旦设置flag[i]=true，表明其想进入临界区，同时turn=j；若j进程在临界区中，则flag[j]=true，满足while条件，i不会进入；若j进程不在临界区，flag[j]=false，不满足while，i可进入临界区。
- 利用flag解决互斥访问，利用turn解决“饥饿”现象

### 2、硬件实现方法

#### 2.1 中断屏蔽方法

- CPU只在发生中断时引起进程切换
- 因此操作为：关中断；执行临界区代码；开中断
- 缺点：
  - 限制了处理机交替执行程序的能力，降低效率
  - 不适用于多CPU系统
  - 用户进程的使用可能很危险，例如：关中断之后，不再打开中断，会导致整个系统无法继续运行；

#### 2.2 Test and Set指令

- TS是一种不可中断的基本原语。它会把“1”写到某个内存位置并传回其旧值，
- 在多进程可同时访问内存的情况下，若一个进程在执行TS指令，在它未执行完成前，其他进程不可执行TS指令
- 为每个临界资源设置一个共享布尔变量lock，true表示正被占用，初值为false。进程进入临界区之前，用TS指令检查lock，若为false，则可以进入，关闭临界资源，lock置为true；若有进程在临界区，则循环检查

#### 2.3 Swap指令

- 该指令功能为交换两个字（字节）的内容
- 为每个临界资源设置一个共享布尔变量lock，再在每个进程中设置局部布尔变量key，用于与lock交换信息。进入临界区前用Swap指令交换lock与key的信息，然后检查key的状态，key为true时重复上述过程

#### 2.4 优缺点

- 优点：适用于任意数目的进程；可支持进程内多个临界区
- 缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待

------

> 无论软硬件方法都有共性的问题：忙等和优先级反转；优先级反转发生是由于低优先级进程运行在临界区时由于高优先级进程就绪而被切换。如果高优先级进程使用忙等的策略尝试进入临界区，他就会忙等下去，低优先级进程不会有机会离开临界区。

### 3、互斥锁（mutex lock）

- 一个进程进入临界区时获得锁（acquire()），退出临界区时释放锁（release()）
- 每个互斥锁有一个布尔变量available，表示锁是否可用，若锁是可用的，调用acquire()会成功，且锁不再可用。

```c
acquire() {
	while(!available)	
	;						//忙等待
	available = false;		//获得锁
}
release() {
	available = true;		//释放锁
}
```

- acquire()和release()的执行是原子操作
- 互斥锁的主要缺点是忙等待；当一个进程在临界区中，其他进程进入临界区必须循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此互斥锁长用于多处理器系统

### 4、信号量

- 同步中，进程经常需要等待某个条件的发生，如果使用忙等待的解决方案，势必浪费大量CPU时间。
- 解决方法：将忙等变为阻塞，可使用两条进程间的通信原语：Sleep和Wakeup
  - Sleep原语将引起调用进程的阻塞，直到另外一个进程用Wakeup原语将其唤醒。

设立两种操作P、V，P操作也称为semWait，V操作也称为semSignal

#### 4.1 信号量定义

- 一个确定的二元组（s, q），s是一个具有非负初值的整形变量，代表资源数目；q是一个初始状态为空的队列

```c
void wait(s) {//P操作：申请资源
	s.count--;
	if(s.count < 0) {//无可用资源
		add this process to s.q;//此进程未申请到资源，进入队列等待
		block this process;
	}
}

void signal(s) {//V操作：释放资源
	s.count++;
	if(s.count <= 0) {//释放了资源仍<=0，说明有等待该资源的进程被阻塞
		remove a process from s.q;//释放一个等待该资源的进程
		place this process on ready list(wakeup);
	}
}
```

#### 4.2 利用信号量实现进程互斥

- 设S为进程1和2互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值为1（即可用资源数为1）；再将临界区置于P(S)和V(S)之间

```c
S = 1;
P1() {
    P(S);
    p1的临界区
    V(S);
}
```

- 任意一个资源要进入临界区，就要执行P操作，将S减为0，进入临界区；此时再有进程进入临界区，执行P操作会被阻塞，等待直至临界区的进程退出

#### 4.3 利用信号量实现进程同步

- 设S为进程1和2同步的信号量，初值为0；进程2中的语句y要使用进程1中语句x的运行结果，所以y要在x之后执行

```c
S = 0;
P1() {
	x;
	V(S);//告诉P2，x已完成
}
P2() {
	P(S);//检查x是否完成
	y;
}
```

- 若进程2先执行到P(S)，S为0，进程2阻塞，放入阻塞队列中，直至进程1的x操作执行完，V操作将进程2放入就绪队列

> 若某个行为要用到某种资源，则在这个行为前面P这种资源；若某个行为提供某种资源，则在这个行为后面V这种资源

#### 4.4 信号量实现前驱关系

![image-20220502200313741](/img/in-post/前驱关系.png)

- 图中可知，C是A和B的后继，要用到A和B的资源，因此在使用前要P这些资源；而对于A和B，它们是提供资源的一方，要在提供之后V这些资源

### 5、管程

信号量及PV操作的问题：

- PV操作不当易导致死锁
- 信号量使用和PV操作需要很高的技巧

#### 5.1 管程的定义和组成

- 管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据；由以下四部分组成
  - 管程的名称
  - 局部于管程内部的共享数据结构说明
  - 对该数据结构进行操作的一组过程（或函数）
  - 对局部于管程内部的共享数据设置初始值的语句

> 类似于面向对象程序设计中的类（class）

- 每次仅允许一个进程进入管程，从而实现进程互斥。若有多个进程同时调用函数，则需等待某个进程运行完它的调用后，下个进程才能开始它的调用（由编译器保证，是一种语言机制）

#### 5.2 条件变量

- 为了区别等待的不同原因，管程又引入了条件变量。不同的条件变量，**对应不同原因的进程阻塞等待队列**，初始时为空。条件变量上能作wait和signal原语操作，若条件变量名为X，则调用同步原语的形式为wait(X)和signal(X)。

- 与信号量相比
  - 类似于PV操作，可实现进程的阻塞和唤醒
  - 条件变量没有“值”，仅实现了排队等待的功能，剩余资源数用管程记录

### 6、经典同步问题

#### 6.1 生产者-消费者问题

#### 6.1.1 问题描述

- 一组生产者进程和一组消费者进程共享一个初始为空，大小为n的缓冲区；只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区非空时，消费者才能从中取出消息，否则必须等待；由于缓冲区是临界资源，他只允许一个生产者放入消息，或一个消费者取出消息。

#### 6.1.2 问题分析

- 生产者和消费者对缓冲区的访问时互斥关系；生产者生产之后，消费者才能消费，他们又是同步关系
- 信号量设置：mutex作为互斥信号量，用于控制互斥访问缓冲池，互斥信号量初值为1；empty为空闲产品数量，初值为n；full为产品数量，初值为0

#### 6.1.3 问题解答

```c
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;
producer() {
	while(1) {
		P(empty);(要用什么，P一下)			 //获取空缓冲区单元
		P(mutex);(互斥夹紧)				   //进入临界区
		add something to buffer(行为)	    //将数据放入缓冲区
		V(mutex);(互斥夹紧)				  //离开临界区，释放互斥信号量
		V(full);(提供什么，V一下)		    //满缓冲区数加1
	}	
}
customer() {
	while(1) {
		P(full);					//获取满缓冲区单元
		P(mutex);					//进入临界区
		remove an item from buffer;	//从缓冲区取出数据
		V(mutex);					//离开临界区，释放互斥信号量
		V(empty);					//提供空缓冲区加1
		consume the item;			//消费数据
	}
}
```

- 两个P操作不可交换，V操作可交换

#### 6.2 读者-写者问题

#### 6.2.1 问题描述

- 对共享资源的读写操作，任意时刻写者最多有一个，读者可以有多个；即读写互斥，写写互斥，读读允许

#### 6.2.2 问题分析

- 对于读者：在实现和写者的互斥时，实现与其他读者的同步；用一个计数器记录当前读者的数量，有读者时写者无法写文件；这里不同读者对计数器的访问也为互斥

#### 6.2.3 问题解答

```c
int cnt = 0;										//读者数量
semaphore mutex = 1;								//读者访问计数器的互斥
semaphore rw = 1;									//读写互斥
writer() {
	P(rw);
	write;
	V(rw);
}
reader() {
	P(mutex);
	if(cnt == 0)									//第一个读进程到来
		P(rw);										//禁止写进程
	cnt++;
	V(mutex);
	read;
	P(mutex);
	cnt--;
	if(cnt == 0)									//最后一个读进程结束	
		V(rw);										//允许写进程
	V(mutex);
}
```

- 上述算法为读者优先，即存在读进程时，写者将被延迟；且只要有一个读进程活跃，随后的读进程都被允许；这样的方式可能会使写进程长时间等待，使写进程“饿死”；
- 若希望写者优先；当有进程在访问数据集的时候，后续等待的写进程优先访问

```c
int wcnt = 0;								//正在等待的写者数量
int rcnt = 0;								//正在访问的读者数量
semaphore rw = 1, ww = 1;					//读写互斥，写互斥
semaphore wmutex = 1, rmutex = 1;			//对计数器的互斥访问
writer() {
	while(1) {
		P(wmutex);
		wcnt++;
		if(wcnt == 1)
			P(rw);							//封锁读进程
		V(wmutex);
        
		P(ww);
		write;
        V(ww);
        
		P(wmutex);
		wcnt--;
		if(wcnt == 0)
			V(rw);							//释放读进程
		V(wmutex);
	}
}
reader() {
	while(1) {
        P(rw);								//只有当写进程都执行完毕释放rw时，读进程才能申请到；
        V(rw);								//立即释放是保证读操作可同步进行；同时写进程来时可直接申请rw，封锁后续读进程
        
		P(rmutex);
		if(rcnt == 0)
			P(ww);							//封锁写进程
		rcnt++;
		V(rmutex);
        
		read;
        
		P(rmutex);
		rcnt--;
		if(rcnt == 0)
			V(ww);							//释放写进程
		V(rmutex);	
	}
}
```

#### 6.3 哲学家就餐问题

#### 6.3.1 问题描述

- 5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。如何保证哲学家们的动作有序进行？

#### 6.3.2 问题分析

- 如何让一名哲学家拿到两根筷子而不造成死锁；制定信号量mutex:当两边的筷子都可用时，才允许他拿起筷子;
- 设第i个科学家左侧筷子为i，右侧筷子为（i + 1）% 5;

#### 6.3.3 问题解答

```c
semaphore chopsticks[5] = {1, 1, 1, 1, 1};				//对五个筷子的互斥访问
semaphore mutex = 1;									//左右筷子都可用时，才能拿起筷子
pi() {
	do{
		P(mutex);
        P(chopsticks[i]);
        P(chopsticks[(i + 1) % 5]);
        V(mutex);
        eat;
        V(chopsticks[(i + 1) % 5]);
        V(chopsticks[i]);
        think;
	}while(1);	
}
```

#### 6.4 吸烟者问题

#### 6.4.1 问题描述

- 有三个抽烟者进程和一个供应者进程；要抽烟需要三个材料：烟草、纸和胶水；三个抽烟者分别有其中的一个，供应者每次将两个材料放到桌子上，拥有剩下那个材料的人会卷一支烟并抽掉它，并给供应者一个信号已经完成，供应者会将下两种材料放到桌子上；重复让三个人轮流吸烟

#### 6.4.2 问题分析

- 供应者与抽烟者是同步关系，抽烟者之间互斥

#### 6.4.3 问题解答

```c
int num = 0;										
semaphore finish = 0;						//抽烟是否完成
semaphore offer1 = 0;
semaphore offer2 = 0;
semaphore offer3 = 0;
provider() {
	while(1) {
		num++;
		num = num % 3;
		if(num == 0)
			V(offer1);
		else if(num == 1)
			V(offer2);
		else 
			V(offer3);
		P(finish);
	}
}
smokeri() {
	P(offeri);
	smoke;
	V(finish);
}
```



